#!/usr/bin/env python3
"""
Debug script to identify why the coefficient generator might be producing non-rank-1 matrices.
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import random
import math

def debug_generate_coefficients():
    """Debug version of _generate_coefficients with detailed logging."""
    
    print("Debug: Generating coefficients...")
    
    # Set seed for reproducible testing
    random.seed(42)
    
    # Rank-one matrix A = a * r^T
    r = [random.randint(-1, 1) for _ in range(4)]
    a = [random.randint(-1, 1) for _ in range(4)]
    
    print(f"Generated base row r: {[f'{x:.6f}' for x in r]}")
    print(f"Generated weights a: {[f'{x:.6f}' for x in a]}")
    
    # Ensure sum(a) isn't zero to keep it interesting
    sum_a = sum(a)
    print(f"Sum of weights: {sum_a:.6f}")
    
    if abs(sum_a) < 0.1:
        a[0] += 0.5
        print(f"Adjusted a[0] to avoid zero sum: {a[0]:.6f}")
    
    # Generate matrix
    matrix = []
    for i in range(4):
        row = []
        for j in range(4):
            element = float(a[i] * r[j])
            row.append(element)
        matrix.append(row)
    
    print("Generated matrix:")
    for i, row in enumerate(matrix):
        print(f"Row {i+1}: {[f'{x:.6f}' for x in row]}")
    
    # Check if this is actually rank-1
    print("\nRank verification:")
    return check_rank_1(matrix)

def check_rank_1(matrix):
    """Check if matrix is rank-1."""
    
    # Find first non-zero row
    base_row_idx = -1
    for i in range(4):
        if any(abs(x) > 1e-10 for x in matrix[i]):
            base_row_idx = i
            break
    
    if base_row_idx == -1:
        print("Matrix is all zeros (rank 0)")
        return False
    
    base_row = matrix[base_row_idx]
    print(f"Base row {base_row_idx + 1}: {[f'{x:.6f}' for x in base_row]}")
    
    all_multiples = True
    for i in range(4):
        if i == base_row_idx:
            continue
            
        row = matrix[i]
        if all(abs(x) < 1e-10 for x in row):
            print(f"Row {i+1}: all zeros (valid multiple)")
            continue
        
        # Find ratio
        ratio = None
        for j in range(4):
            if abs(base_row[j]) > 1e-10:
                ratio = row[j] / base_row[j]
                break
        
        if ratio is None:
            print(f"Row {i+1}: ERROR - base row is zero but current row is not")
            all_multiples = False
            continue
        
        # Check if row = ratio * base_row
        matches = True
        for j in range(4):
            expected = ratio * base_row[j]
            if abs(row[j] - expected) > 1e-10:
                matches = False
                break
        
        print(f"Row {i+1}: ratio = {ratio:.6f}, matches = {matches}")
        if not matches:
            all_multiples = False
    
    print(f"\nIs rank-1: {all_multiples}")
    return all_multiples

def test_problematic_matrix():
    """Test the specific problematic matrix."""
    
    print("\n" + "="*60)
    print("Testing the problematic matrix from feedback:")
    print("="*60)
    
    # The problematic matrix
    matrix = [
        [0.004, -0.082, -0.197, 0.057],
        [-0.031, 0.614, 1.483, -0.431],
        [-0.023, 0.452, 1.090, -0.317],
        [0.029, -0.574, -1.384, 0.403]
    ]
    
    print("Matrix:")
    for i, row in enumerate(matrix):
        print(f"Row {i+1}: {[f'{x:.4f}' for x in row]}")
    
    is_rank_1 = check_rank_1(matrix)
    print(f"\nConclusion: This matrix is {'RANK-1' if is_rank_1 else 'NOT RANK-1'}")
    
    if not is_rank_1:
        print("This matrix was NOT generated by the current _generate_coefficients method.")
        print("It must be legacy data or from a different source.")

if __name__ == '__main__':
    # Test current generation logic
    is_rank_1 = debug_generate_coefficients()
    
    if is_rank_1:
        print("\n✓ Current generation logic produces rank-1 matrices correctly.")
    else:
        print("\n✗ Current generation logic has a bug!")
    
    # Test the problematic matrix
    test_problematic_matrix()